# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pay` gem.
# Please instead update this file by running `bin/tapioca gem pay`.

# A subscription has moved from the Active status to the Past Due status. This will only be triggered when the initial transaction in a billing cycle is declined. Once the status moves to past due, it will not be triggered again in that billing cycle.
#
# source://pay//lib/pay/version.rb#1
module Pay
  # source://pay//lib/pay.rb#34
  def application_name; end

  # source://pay//lib/pay.rb#34
  def application_name=(val); end

  # source://pay//lib/pay.rb#40
  def automount_routes; end

  # source://pay//lib/pay.rb#40
  def automount_routes=(val); end

  # source://pay//lib/pay.rb#28
  def braintree_gateway; end

  # source://pay//lib/pay.rb#28
  def braintree_gateway=(val); end

  # source://pay//lib/pay.rb#35
  def business_address; end

  # source://pay//lib/pay.rb#35
  def business_address=(val); end

  # source://pay//lib/pay.rb#37
  def business_logo; end

  # source://pay//lib/pay.rb#37
  def business_logo=(val); end

  # source://pay//lib/pay.rb#36
  def business_name; end

  # source://pay//lib/pay.rb#36
  def business_name=(val); end

  # source://pay//lib/pay.rb#46
  def default_plan_name; end

  # source://pay//lib/pay.rb#46
  def default_plan_name=(val); end

  # source://pay//lib/pay.rb#43
  def default_product_name; end

  # source://pay//lib/pay.rb#43
  def default_product_name=(val); end

  # source://pay//lib/pay.rb#55
  def emails; end

  # source://pay//lib/pay.rb#55
  def emails=(val); end

  # source://pay//lib/pay.rb#52
  def enabled_processors; end

  # source://pay//lib/pay.rb#52
  def enabled_processors=(val); end

  # source://pay//lib/pay.rb#82
  def mail_arguments; end

  # source://pay//lib/pay.rb#82
  def mail_arguments=(val); end

  # source://pay//lib/pay.rb#91
  def mail_to; end

  # source://pay//lib/pay.rb#91
  def mail_to=(val); end

  # source://pay//lib/pay.rb#30
  def model_parent_class; end

  # source://pay//lib/pay.rb#30
  def model_parent_class=(val); end

  # source://pay//lib/pay.rb#78
  def parent_mailer; end

  # source://pay//lib/pay.rb#78
  def parent_mailer=(val); end

  # source://pay//lib/pay.rb#49
  def routes_path; end

  # source://pay//lib/pay.rb#49
  def routes_path=(val); end

  # source://pay//lib/pay.rb#38
  def support_email; end

  # source://pay//lib/pay.rb#38
  def support_email=(val); end

  class << self
    # source://pay//lib/pay.rb#34
    def application_name; end

    # source://pay//lib/pay.rb#34
    def application_name=(val); end

    # source://pay//lib/pay.rb#40
    def automount_routes; end

    # source://pay//lib/pay.rb#40
    def automount_routes=(val); end

    # source://pay//lib/pay.rb#28
    def braintree_gateway; end

    # source://pay//lib/pay.rb#28
    def braintree_gateway=(val); end

    # source://pay//lib/pay.rb#35
    def business_address; end

    # source://pay//lib/pay.rb#35
    def business_address=(val); end

    # source://pay//lib/pay.rb#37
    def business_logo; end

    # source://pay//lib/pay.rb#37
    def business_logo=(val); end

    # source://pay//lib/pay.rb#36
    def business_name; end

    # source://pay//lib/pay.rb#36
    def business_name=(val); end

    # source://pay//lib/pay.rb#46
    def default_plan_name; end

    # source://pay//lib/pay.rb#46
    def default_plan_name=(val); end

    # source://pay//lib/pay.rb#43
    def default_product_name; end

    # source://pay//lib/pay.rb#43
    def default_product_name=(val); end

    # source://pay//lib/pay.rb#55
    def emails; end

    # source://pay//lib/pay.rb#55
    def emails=(val); end

    # source://pay//lib/pay.rb#52
    def enabled_processors; end

    # source://pay//lib/pay.rb#52
    def enabled_processors=(val); end

    # source://pay//lib/pay.rb#82
    def mail_arguments; end

    # source://pay//lib/pay.rb#82
    def mail_arguments=(val); end

    # source://pay//lib/pay.rb#91
    def mail_to; end

    # source://pay//lib/pay.rb#91
    def mail_to=(val); end

    # source://pay//lib/pay.rb#74
    def mailer; end

    # source://pay//lib/pay.rb#69
    def mailer=(value); end

    # source://pay//lib/pay.rb#30
    def model_parent_class; end

    # source://pay//lib/pay.rb#30
    def model_parent_class=(val); end

    # source://pay//lib/pay.rb#78
    def parent_mailer; end

    # source://pay//lib/pay.rb#78
    def parent_mailer=(val); end

    # source://pay//lib/pay.rb#49
    def routes_path; end

    # source://pay//lib/pay.rb#49
    def routes_path=(val); end

    # @return [Boolean]
    #
    # source://pay//lib/pay.rb#107
    def send_email?(email_option, *remaining_args); end

    # @yield [_self]
    # @yieldparam _self [Pay] the object that the method was called on
    #
    # source://pay//lib/pay.rb#103
    def setup; end

    # source://pay//lib/pay.rb#38
    def support_email; end

    # source://pay//lib/pay.rb#38
    def support_email=(val); end
  end
end

# source://pay//lib/pay/errors.rb#14
class Pay::ActionRequired < ::Pay::PaymentError
  # source://pay//lib/pay/errors.rb#15
  def message; end
end

# source://pay//lib/pay/adapter.rb#2
module Pay::Adapter
  extend ::ActiveSupport::Concern

  class << self
    # source://pay//lib/pay/adapter.rb#5
    def current_adapter; end

    # source://pay//lib/pay/adapter.rb#13
    def json_column_type; end
  end
end

class Pay::ApplicationController < ::ActionController::Base
  private

  # source://actionview/7.0.4/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  class << self
    # source://activesupport/7.0.4/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://actionpack/7.0.4/lib/action_dispatch/routing/route_set.rb#564
    def _routes; end

    # source://actionpack/7.0.4/lib/action_controller/metal/params_wrapper.rb#185
    def _wrapper_options; end

    # source://actionpack/7.0.4/lib/action_controller/metal/helpers.rb#63
    def helpers_path; end

    # source://actionpack/7.0.4/lib/action_controller/metal.rb#210
    def middleware_stack; end
  end
end

module Pay::ApplicationController::HelperMethods
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::InertiaRails::Helper
  include ::ViteRails::TagHelpers
  include ::ActionController::Base::HelperMethods
  include ::Pay::ApplicationHelper
  include ::DeviseHelper
end

module Pay::ApplicationHelper; end
class Pay::ApplicationJob < ::ActiveJob::Base; end

class Pay::ApplicationMailer < ::ActionMailer::Base
  private

  # source://actionview/7.0.4/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  class << self
    # source://actionview/7.0.4/lib/action_view/layouts.rb#209
    def _layout; end

    # source://actionview/7.0.4/lib/action_view/layouts.rb#210
    def _layout_conditions; end

    # source://actionpack/7.0.4/lib/action_dispatch/routing/route_set.rb#564
    def _routes; end

    # source://actionmailer/7.0.4/lib/action_mailer/base.rb#490
    def default_params; end
  end
end

class Pay::ApplicationRecord < ::ApplicationRecord
  include ::Pay::ApplicationRecord::GeneratedAttributeMethods
  include ::Pay::ApplicationRecord::GeneratedAssociationMethods

  class << self
    # source://activemodel/7.0.4/lib/active_model/validations.rb#52
    def _validators; end

    # source://activerecord/7.0.4/lib/active_record/enum.rb#116
    def defined_enums; end

    # source://activerecord/7.0.4/lib/active_record/model_schema.rb#152
    def table_name_prefix; end
  end
end

module Pay::ApplicationRecord::GeneratedAssociationMethods; end
module Pay::ApplicationRecord::GeneratedAttributeMethods; end

# Adds Pay methods to ActiveRecord models
#
# source://pay//lib/pay/attributes.rb#4
module Pay::Attributes
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Pay::Attributes::ClassMethods
end

# source://pay//lib/pay/attributes.rb#0
module Pay::Attributes::ClassMethods
  # source://pay//lib/pay/attributes.rb#86
  def pay_customer(options = T.unsafe(nil)); end

  # source://pay//lib/pay/attributes.rb#95
  def pay_merchant(options = T.unsafe(nil)); end
end

# source://pay//lib/pay/attributes.rb#7
module Pay::Attributes::CustomerExtension
  extend ::ActiveSupport::Concern

  # @raise [Pay::Error]
  #
  # source://pay//lib/pay/attributes.rb#42
  def add_payment_processor(processor_name, allow_fake: T.unsafe(nil), **attributes); end

  # source://pay//lib/pay/attributes.rb#60
  def cancel_active_pay_subscriptions!; end

  # source://pay//lib/pay/attributes.rb#50
  def payment_processor; end

  # Changes a user's payment processor
  #
  # This has several effects:
  # - Finds or creates a Pay::Customer for the process and marks it as default
  # - Removes the default flag from all other Pay::Customers
  # - Removes the default flag from all Pay::PaymentMethods
  #
  # @raise [Pay::Error]
  #
  # source://pay//lib/pay/attributes.rb#29
  def set_payment_processor(processor_name, allow_fake: T.unsafe(nil), **attributes); end
end

# source://pay//lib/pay/attributes.rb#65
module Pay::Attributes::MerchantExtension
  extend ::ActiveSupport::Concern

  # source://pay//lib/pay/attributes.rb#73
  def set_merchant_processor(processor_name, **attributes); end
end

# source://pay//lib/pay.rb#24
module Pay::Billable; end

# source://pay//lib/pay/billable/sync_customer.rb#3
module Pay::Billable::SyncCustomer
  extend ::ActiveSupport::Concern

  # @return [Boolean]
  #
  # source://pay//lib/pay/billable/sync_customer.rb#14
  def pay_should_sync_customer?; end

  private

  # source://pay//lib/pay/billable/sync_customer.rb#20
  def enqeue_customer_sync_job; end
end

# source://pay//lib/pay/braintree.rb#2
module Pay::Braintree
  extend ::Pay::Env

  class << self
    # source://pay//lib/pay/braintree.rb#53
    def configure_webhooks; end

    # @return [Boolean]
    #
    # source://pay//lib/pay/braintree.rb#22
    def enabled?; end

    # source://pay//lib/pay/braintree.rb#49
    def environment; end

    # source://pay//lib/pay/braintree.rb#45
    def merchant_id; end

    # source://pay//lib/pay/braintree.rb#41
    def private_key; end

    # source://pay//lib/pay/braintree.rb#37
    def public_key; end

    # source://pay//lib/pay/braintree.rb#28
    def setup; end
  end
end

# source://pay//lib/pay/braintree/authorization_error.rb#3
class Pay::Braintree::AuthorizationError < ::Pay::Braintree::Error
  # source://pay//lib/pay/braintree/authorization_error.rb#4
  def message; end
end

# source://pay//lib/pay/braintree/billable.rb#3
class Pay::Braintree::Billable
  # @return [Billable] a new instance of Billable
  #
  # source://pay//lib/pay/braintree/billable.rb#14
  def initialize(pay_customer); end

  # source://pay//lib/pay/braintree/billable.rb#126
  def add_payment_method(token, default: T.unsafe(nil)); end

  # source://pay//lib/pay/braintree/billable.rb#241
  def card_details_for_braintree_transaction(transaction); end

  # source://pay//lib/pay/braintree/billable.rb#75
  def charge(amount, options = T.unsafe(nil)); end

  # Retrieve the Braintree::Customer object
  #
  # - If no processor_id is present, creates a Customer.
  # - When 'payment_method_token' is present, it will also set the default payment method
  #
  # source://pay//lib/pay/braintree/billable.rb#40
  def customer; end

  # Returns a hash of attributes for the Stripe::Customer object
  #
  # source://pay//lib/pay/braintree/billable.rb#19
  def customer_attributes; end

  # source://pay//lib/pay/braintree/billable.rb#6
  def customer_name(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/billable.rb#6
  def email(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/billable.rb#184
  def gateway; end

  # Returns the value of attribute pay_customer.
  #
  # source://pay//lib/pay/braintree/billable.rb#4
  def pay_customer; end

  # source://pay//lib/pay/braintree/billable.rb#6
  def payment_method_token(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/billable.rb#6
  def payment_method_token?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/billable.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/billable.rb#6
  def processor_id?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/billable.rb#161
  def processor_subscription(subscription_id, options = T.unsafe(nil)); end

  # source://pay//lib/pay/braintree/billable.rb#188
  def save_payment_method(payment_method, default:); end

  # source://pay//lib/pay/braintree/billable.rb#165
  def save_transaction(transaction); end

  # source://pay//lib/pay/braintree/billable.rb#93
  def subscribe(name: T.unsafe(nil), plan: T.unsafe(nil), **options); end

  # source://pay//lib/pay/braintree/billable.rb#155
  def trial_end_date(subscription); end

  # Syncs name and email to Braintree::Customer
  # You can also pass in other attributes that will be merged into the default attributes
  #
  # source://pay//lib/pay/braintree/billable.rb#70
  def update_customer!(**attributes); end
end

# source://pay//lib/pay/braintree/charge.rb#3
class Pay::Braintree::Charge
  # @return [Charge] a new instance of Charge
  #
  # source://pay//lib/pay/braintree/charge.rb#8
  def initialize(pay_charge); end

  # source://pay//lib/pay/braintree/charge.rb#12
  def charge; end

  # Returns the value of attribute pay_charge.
  #
  # source://pay//lib/pay/braintree/charge.rb#4
  def pay_charge; end

  # source://pay//lib/pay/braintree/charge.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/charge.rb#18
  def refund!(amount_to_refund); end
end

# source://pay//lib/pay/braintree/error.rb#5
class Pay::Braintree::Error < ::Pay::Error
  # @return [Error] a new instance of Error
  #
  # source://pay//lib/pay/braintree/error.rb#9
  def initialize(result); end

  # source://pay//lib/pay/braintree/error.rb#18
  def cause; end

  # For any manually raised Braintree error results (for failure responses)
  # we can raise this exception manually but treat it as if we wrapped an exception
  #
  # source://pay//lib/pay/braintree/error.rb#7
  def result; end
end

# source://pay//lib/pay/braintree/payment_method.rb#3
class Pay::Braintree::PaymentMethod
  # @return [PaymentMethod] a new instance of PaymentMethod
  #
  # source://pay//lib/pay/braintree/payment_method.rb#17
  def initialize(pay_payment_method); end

  # source://pay//lib/pay/braintree/payment_method.rb#6
  def customer(*_arg0, **_arg1, &_arg2); end

  # Remove payment method
  #
  # @raise [Pay::Braintree::Error]
  #
  # source://pay//lib/pay/braintree/payment_method.rb#29
  def detach; end

  # Sets payment method as default on Stripe
  #
  # @raise [Pay::Braintree::Error]
  #
  # source://pay//lib/pay/braintree/payment_method.rb#22
  def make_default!; end

  # Returns the value of attribute pay_payment_method.
  #
  # source://pay//lib/pay/braintree/payment_method.rb#4
  def pay_payment_method; end

  # source://pay//lib/pay/braintree/payment_method.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  private

  # source://pay//lib/pay/braintree/payment_method.rb#37
  def gateway; end

  class << self
    # source://pay//lib/pay/braintree/payment_method.rb#8
    def sync(id, object: T.unsafe(nil), try: T.unsafe(nil), retries: T.unsafe(nil)); end
  end
end

# source://pay//lib/pay/braintree/subscription.rb#3
class Pay::Braintree::Subscription
  # @return [Subscription] a new instance of Subscription
  #
  # source://pay//lib/pay/braintree/subscription.rb#23
  def initialize(pay_subscription); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def active?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/subscription.rb#31
  def cancel(**options); end

  # source://pay//lib/pay/braintree/subscription.rb#47
  def cancel_now!(**options); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def canceled?(*_arg0, **_arg1, &_arg2); end

  # @raise [NotImplementedError]
  #
  # source://pay//lib/pay/braintree/subscription.rb#59
  def change_quantity(quantity, **options); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def customer(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def ends_at(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def name(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://pay//lib/pay/braintree/subscription.rb#63
  def on_grace_period?; end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def on_trial?(*_arg0, **_arg1, &_arg2); end

  # @raise [NotImplementedError]
  #
  # source://pay//lib/pay/braintree/subscription.rb#71
  def pause; end

  # @return [Boolean]
  #
  # source://pay//lib/pay/braintree/subscription.rb#67
  def paused?; end

  # Returns the value of attribute pay_subscription.
  #
  # source://pay//lib/pay/braintree/subscription.rb#4
  def pay_subscription; end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def processor_plan(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def processor_subscription(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def prorate(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def prorate?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def quantity(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def quantity?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/braintree/subscription.rb#75
  def resume; end

  # Retries the latest invoice for a Past Due subscription
  #
  # source://pay//lib/pay/braintree/subscription.rb#143
  def retry_failed_payment; end

  # source://pay//lib/pay/braintree/subscription.rb#27
  def subscription(**options); end

  # source://pay//lib/pay/braintree/subscription.rb#104
  def swap(plan, **options); end

  # source://pay//lib/pay/braintree/subscription.rb#6
  def trial_ends_at(*_arg0, **_arg1, &_arg2); end

  private

  # source://pay//lib/pay/braintree/subscription.rb#175
  def discount_for_switching_to_monthly(current_plan, plan); end

  # source://pay//lib/pay/braintree/subscription.rb#188
  def discount_for_switching_to_yearly; end

  # source://pay//lib/pay/braintree/subscription.rb#165
  def find_braintree_plan(id); end

  # source://pay//lib/pay/braintree/subscription.rb#157
  def gateway; end

  # source://pay//lib/pay/braintree/subscription.rb#183
  def money_remaining_on_yearly_plan(current_plan); end

  # source://pay//lib/pay/braintree/subscription.rb#203
  def swap_across_frequencies(plan); end

  # Helper methods for swapping plans
  #
  # @return [Boolean]
  #
  # source://pay//lib/pay/braintree/subscription.rb#171
  def switching_to_monthly_plan?(current_plan, plan); end

  # @return [Boolean]
  #
  # source://pay//lib/pay/braintree/subscription.rb#161
  def would_change_billing_frequency?(plan); end
end

# source://pay//lib/pay/braintree.rb#10
module Pay::Braintree::Webhooks; end

# source://pay//lib/pay/braintree/webhooks/subscription_canceled.rb#6
class Pay::Braintree::Webhooks::SubscriptionCanceled
  # source://pay//lib/pay/braintree/webhooks/subscription_canceled.rb#7
  def call(event); end
end

# source://pay//lib/pay/braintree/webhooks/subscription_charged_successfully.rb#6
class Pay::Braintree::Webhooks::SubscriptionChargedSuccessfully
  # source://pay//lib/pay/braintree/webhooks/subscription_charged_successfully.rb#7
  def call(event); end
end

# source://pay//lib/pay/braintree/webhooks/subscription_charged_unsuccessfully.rb#6
class Pay::Braintree::Webhooks::SubscriptionChargedUnsuccessfully
  # source://pay//lib/pay/braintree/webhooks/subscription_charged_unsuccessfully.rb#7
  def call(event); end
end

# source://pay//lib/pay/braintree/webhooks/subscription_expired.rb#6
class Pay::Braintree::Webhooks::SubscriptionExpired
  # source://pay//lib/pay/braintree/webhooks/subscription_expired.rb#7
  def call(event); end
end

# source://pay//lib/pay/braintree/webhooks/subscription_trial_ended.rb#6
class Pay::Braintree::Webhooks::SubscriptionTrialEnded
  # source://pay//lib/pay/braintree/webhooks/subscription_trial_ended.rb#7
  def call(event); end
end

# source://pay//lib/pay/braintree/webhooks/subscription_went_active.rb#6
class Pay::Braintree::Webhooks::SubscriptionWentActive
  # source://pay//lib/pay/braintree/webhooks/subscription_went_active.rb#7
  def call(event); end
end

# source://pay//lib/pay/braintree/webhooks/subscription_went_past_due.rb#6
class Pay::Braintree::Webhooks::SubscriptionWentPastDue
  # source://pay//lib/pay/braintree/webhooks/subscription_went_past_due.rb#7
  def call(event); end
end

class Pay::Charge < ::Pay::ApplicationRecord
  include ::Pay::Charge::GeneratedAttributeMethods
  include ::Pay::Charge::GeneratedAssociationMethods

  def amount_refunded_with_currency; end
  def amount_with_currency; end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_customer(*args); end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_subscription(*args); end

  def braintree?; end
  def capture(*_arg0, **_arg1, &_arg2); end
  def captured?; end
  def charged_to; end
  def credit_note!(*_arg0, **_arg1, &_arg2); end
  def credit_notes(*_arg0, **_arg1, &_arg2); end
  def fake_processor?; end
  def full_refund?; end
  def line_items; end
  def paddle?; end
  def partial_refund?; end
  def payment_processor; end
  def processor_charge; end
  def refund!(refund_amount = T.unsafe(nil)); end
  def refunded?; end
  def stripe?; end

  class << self
    # source://activesupport/7.0.4/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activerecord/7.0.4/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.0.4/lib/active_model/validations.rb#52
    def _validators; end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def braintree(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/enum.rb#116
    def defined_enums; end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def fake_processor(*args, **_arg1); end

    def find_by_processor_and_id(processor, processor_id); end

    # source://activerecord/7.0.4/lib/active_record/model_schema.rb#160
    def inheritance_column; end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def paddle(*args, **_arg1); end

    def pay_processor_for(name); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def sorted(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def stripe(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def with_active_customer(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def with_deleted_customer(*args, **_arg1); end
  end
end

module Pay::Charge::GeneratedAssociationMethods
  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#28
  def build_customer(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#28
  def build_subscription(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#32
  def create_customer(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_customer!(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#32
  def create_subscription(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_subscription!(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#103
  def customer; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#111
  def customer=(value); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#132
  def customer_changed?; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#136
  def customer_previously_changed?; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_customer; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_subscription; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#103
  def subscription; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#111
  def subscription=(value); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#132
  def subscription_changed?; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#136
  def subscription_previously_changed?; end
end

module Pay::Charge::GeneratedAttributeMethods; end

# source://pay//lib/pay/currency.rb#2
class Pay::Currency
  include ::ActionView::Helpers::NumberHelper

  # @return [Currency] a new instance of Currency
  #
  # source://pay//lib/pay/currency.rb#20
  def initialize(iso_code); end

  # If amount is 0.8, we want to display $0.008
  #
  # source://pay//lib/pay/currency.rb#47
  def additional_precision(amount); end

  # Returns the value of attribute attributes.
  #
  # source://pay//lib/pay/currency.rb#5
  def attributes; end

  # source://pay//lib/pay/currency.rb#60
  def delimiter; end

  # source://pay//lib/pay/currency.rb#64
  def format; end

  # source://pay//lib/pay/currency.rb#24
  def format_amount(amount, **options); end

  # Returns the precision to display
  #
  # If 1, returns 0
  # If 100, returns 2
  # If 1000, returns 3
  #
  # source://pay//lib/pay/currency.rb#42
  def precision; end

  # source://pay//lib/pay/currency.rb#56
  def separator; end

  # source://pay//lib/pay/currency.rb#72
  def subunit; end

  # @return [Boolean]
  #
  # source://pay//lib/pay/currency.rb#68
  def subunit?; end

  # source://pay//lib/pay/currency.rb#76
  def subunit_to_unit; end

  # source://pay//lib/pay/currency.rb#52
  def unit; end

  class << self
    # source://pay//lib/pay/currency.rb#7
    def all; end

    # Takes an amount (in cents) and currency and returns the formatted version for the currency
    #
    # source://pay//lib/pay/currency.rb#15
    def format(amount, currency:, **options); end
  end
end

class Pay::Customer < ::Pay::ApplicationRecord
  include ::Pay::Customer::GeneratedAttributeMethods
  include ::Pay::Customer::GeneratedAssociationMethods

  def active?; end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_charges(*args); end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_default_payment_method(*args); end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_owner(*args); end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_payment_methods(*args); end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_subscriptions(*args); end

  def braintree?; end
  def customer_name; end
  def deleted?; end
  def email(*_arg0, **_arg1, &_arg2); end
  def fake_processor?; end
  def has_incomplete_payment?; end

  # source://activesupport/7.0.4/lib/active_support/core_ext/module/delegation.rb#302
  def method_missing(method, *args, **_arg2, &block); end

  def on_generic_trial?; end
  def on_trial?(name: T.unsafe(nil), plan: T.unsafe(nil)); end
  def on_trial_or_subscribed?(name: T.unsafe(nil), processor_plan: T.unsafe(nil)); end
  def paddle?; end
  def pay_processor; end
  def retry_past_due_subscriptions!; end
  def stripe?; end
  def subscribed?(name: T.unsafe(nil), processor_plan: T.unsafe(nil)); end
  def subscription(name: T.unsafe(nil)); end
  def update_payment_method(payment_method_id); end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_charges(*args); end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_payment_methods(*args); end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_subscriptions(*args); end

  private

  # source://activesupport/7.0.4/lib/active_support/core_ext/module/delegation.rb#294
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    # source://activesupport/7.0.4/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activerecord/7.0.4/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.0.4/lib/active_model/validations.rb#52
    def _validators; end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def active(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads; end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def braintree(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/enum.rb#116
    def defined_enums; end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def deleted(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def fake_processor(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def not_fake_processor(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def paddle(*args, **_arg1); end

    def pay_processor_for(name); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def stripe(*args, **_arg1); end
  end
end

module Pay::Customer::GeneratedAssociationMethods
  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#28
  def build_default_payment_method(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/collection_association.rb#62
  def charge_ids; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/collection_association.rb#72
  def charge_ids=(ids); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#103
  def charges; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#111
  def charges=(value); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#32
  def create_default_payment_method(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_default_payment_method!(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#103
  def default_payment_method; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#111
  def default_payment_method=(value); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#103
  def owner; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#111
  def owner=(value); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#132
  def owner_changed?; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#136
  def owner_previously_changed?; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/collection_association.rb#62
  def payment_method_ids; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/collection_association.rb#72
  def payment_method_ids=(ids); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#103
  def payment_methods; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#111
  def payment_methods=(value); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_default_payment_method; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_owner; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/collection_association.rb#62
  def subscription_ids; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/collection_association.rb#72
  def subscription_ids=(ids); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#103
  def subscriptions; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#111
  def subscriptions=(value); end
end

module Pay::Customer::GeneratedAttributeMethods; end

class Pay::CustomerSyncJob < ::Pay::ApplicationJob
  def perform(pay_customer_id); end
end

# source://pay//lib/pay/engine.rb#4
class Pay::Engine < ::Rails::Engine
  # Determines if a gem version matches requirements
  # Used for verifying that dependencies are correct
  #
  # @return [Boolean]
  #
  # source://pay//lib/pay/engine.rb#44
  def version_matches?(current:, required:); end

  class << self
    # source://activesupport/7.0.4/lib/active_support/callbacks.rb#68
    def __callbacks; end
  end
end

# source://pay//lib/pay/env.rb#2
module Pay::Env
  private

  # source://pay//lib/pay/env.rb#38
  def credentials; end

  # source://pay//lib/pay/env.rb#30
  def env; end

  # Search for environment variables
  #
  # We must handle a lot of different cases, including the new Rails 6
  # environment separated credentials files which have no nesting for
  # the current environment.
  #
  # 1. Check environment variable
  # 2. Check environment scoped credentials, then secrets
  # 3. Check unscoped credentials, then secrets
  #
  # source://pay//lib/pay/env.rb#14
  def find_value_by_name(scope, name); end

  # source://pay//lib/pay/env.rb#34
  def secrets; end
end

# https://avdi.codes/exception-causes-in-ruby-2-1/
#
# source://pay//lib/pay/errors.rb#3
class Pay::Error < ::StandardError; end

# source://pay//lib/pay/fake_processor.rb#2
module Pay::FakeProcessor; end

# source://pay//lib/pay/fake_processor/billable.rb#3
class Pay::FakeProcessor::Billable
  # @return [Billable] a new instance of Billable
  #
  # source://pay//lib/pay/fake_processor/billable.rb#13
  def initialize(pay_customer); end

  # source://pay//lib/pay/fake_processor/billable.rb#62
  def add_payment_method(payment_method_id, default: T.unsafe(nil)); end

  # source://pay//lib/pay/fake_processor/billable.rb#6
  def card_token(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/billable.rb#26
  def charge(amount, options = T.unsafe(nil)); end

  # source://pay//lib/pay/fake_processor/billable.rb#17
  def customer; end

  # source://pay//lib/pay/fake_processor/billable.rb#6
  def customer_name(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/billable.rb#6
  def email(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute pay_customer.
  #
  # source://pay//lib/pay/fake_processor/billable.rb#4
  def pay_customer; end

  # source://pay//lib/pay/fake_processor/billable.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/billable.rb#6
  def processor_id?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/billable.rb#82
  def processor_subscription(subscription_id, options = T.unsafe(nil)); end

  # source://pay//lib/pay/fake_processor/billable.rb#44
  def subscribe(name: T.unsafe(nil), plan: T.unsafe(nil), **options); end

  # source://pay//lib/pay/fake_processor/billable.rb#86
  def trial_end_date(subscription); end

  # source://pay//lib/pay/fake_processor/billable.rb#22
  def update_customer!; end
end

# source://pay//lib/pay/fake_processor/charge.rb#3
class Pay::FakeProcessor::Charge
  # @return [Charge] a new instance of Charge
  #
  # source://pay//lib/pay/fake_processor/charge.rb#8
  def initialize(pay_charge); end

  # source://pay//lib/pay/fake_processor/charge.rb#12
  def charge; end

  # source://pay//lib/pay/fake_processor/charge.rb#6
  def owner(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute pay_charge.
  #
  # source://pay//lib/pay/fake_processor/charge.rb#4
  def pay_charge; end

  # source://pay//lib/pay/fake_processor/charge.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/charge.rb#16
  def refund!(amount_to_refund); end
end

# source://pay//lib/pay/fake_processor/error.rb#3
class Pay::FakeProcessor::Error < ::Pay::Error; end

# source://pay//lib/pay/fake_processor/merchant.rb#3
class Pay::FakeProcessor::Merchant
  # @return [Merchant] a new instance of Merchant
  #
  # source://pay//lib/pay/fake_processor/merchant.rb#7
  def initialize(pay_merchant); end

  # source://pay//lib/pay/fake_processor/merchant.rb#17
  def account_link(refresh_url:, return_url:, type: T.unsafe(nil), **options); end

  # source://pay//lib/pay/fake_processor/merchant.rb#11
  def create_account(**options); end

  # source://pay//lib/pay/fake_processor/merchant.rb#21
  def login_link(**options); end

  # Returns the value of attribute pay_merchant.
  #
  # source://pay//lib/pay/fake_processor/merchant.rb#4
  def pay_merchant; end

  # source://pay//lib/pay/fake_processor/merchant.rb#5
  def processor_id(*_arg0, **_arg1, &_arg2); end
end

# source://pay//lib/pay/fake_processor/payment_method.rb#3
class Pay::FakeProcessor::PaymentMethod
  # @return [PaymentMethod] a new instance of PaymentMethod
  #
  # source://pay//lib/pay/fake_processor/payment_method.rb#8
  def initialize(pay_payment_method); end

  # source://pay//lib/pay/fake_processor/payment_method.rb#6
  def customer(*_arg0, **_arg1, &_arg2); end

  # Remove payment method
  #
  # source://pay//lib/pay/fake_processor/payment_method.rb#17
  def detach; end

  # Sets payment method as default on Stripe
  #
  # source://pay//lib/pay/fake_processor/payment_method.rb#13
  def make_default!; end

  # Returns the value of attribute pay_payment_method.
  #
  # source://pay//lib/pay/fake_processor/payment_method.rb#4
  def pay_payment_method; end

  # source://pay//lib/pay/fake_processor/payment_method.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end
end

# source://pay//lib/pay/fake_processor/subscription.rb#3
class Pay::FakeProcessor::Subscription
  # @return [Subscription] a new instance of Subscription
  #
  # source://pay//lib/pay/fake_processor/subscription.rb#20
  def initialize(pay_subscription); end

  # source://pay//lib/pay/fake_processor/subscription.rb#6
  def active?(*_arg0, **_arg1, &_arg2); end

  # With trial, sets end to trial end (mimicing Stripe)
  # Without trial, sets can ends_at to end of month
  #
  # source://pay//lib/pay/fake_processor/subscription.rb#30
  def cancel(**options); end

  # source://pay//lib/pay/fake_processor/subscription.rb#38
  def cancel_now!(**options); end

  # source://pay//lib/pay/fake_processor/subscription.rb#6
  def canceled?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/subscription.rb#47
  def change_quantity(quantity, **options); end

  # source://pay//lib/pay/fake_processor/subscription.rb#6
  def ends_at(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://pay//lib/pay/fake_processor/subscription.rb#51
  def on_grace_period?; end

  # source://pay//lib/pay/fake_processor/subscription.rb#6
  def on_trial?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/subscription.rb#6
  def owner(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/subscription.rb#59
  def pause; end

  # @return [Boolean]
  #
  # source://pay//lib/pay/fake_processor/subscription.rb#55
  def paused?; end

  # Returns the value of attribute pay_subscription.
  #
  # source://pay//lib/pay/fake_processor/subscription.rb#4
  def pay_subscription; end

  # source://pay//lib/pay/fake_processor/subscription.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/subscription.rb#6
  def processor_plan(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/subscription.rb#6
  def processor_subscription(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/subscription.rb#6
  def prorate(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/subscription.rb#6
  def quantity(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/subscription.rb#6
  def quantity?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/fake_processor/subscription.rb#63
  def resume; end

  # Retries the latest invoice for a Past Due subscription
  #
  # source://pay//lib/pay/fake_processor/subscription.rb#74
  def retry_failed_payment; end

  # source://pay//lib/pay/fake_processor/subscription.rb#24
  def subscription(**options); end

  # source://pay//lib/pay/fake_processor/subscription.rb#69
  def swap(plan, **options); end
end

# source://pay//lib/pay/errors.rb#20
class Pay::InvalidPaymentMethod < ::Pay::PaymentError
  # source://pay//lib/pay/errors.rb#21
  def message; end
end

class Pay::Merchant < ::Pay::ApplicationRecord
  include ::Pay::Merchant::GeneratedAttributeMethods
  include ::Pay::Merchant::GeneratedAssociationMethods

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_owner(*args); end

  # source://activesupport/7.0.4/lib/active_support/core_ext/module/delegation.rb#302
  def method_missing(method, *args, **_arg2, &block); end

  def onboarding_complete?; end
  def pay_processor; end

  private

  # source://activesupport/7.0.4/lib/active_support/core_ext/module/delegation.rb#294
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    # source://activesupport/7.0.4/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activerecord/7.0.4/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.0.4/lib/active_model/validations.rb#52
    def _validators; end

    # source://activerecord/7.0.4/lib/active_record/enum.rb#116
    def defined_enums; end

    def pay_processor_for(name); end
  end
end

module Pay::Merchant::GeneratedAssociationMethods
  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#103
  def owner; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#111
  def owner=(value); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#132
  def owner_changed?; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#136
  def owner_previously_changed?; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_owner; end
end

module Pay::Merchant::GeneratedAttributeMethods; end

# source://pay//lib/pay/nano_id.rb#2
module Pay::NanoId
  class << self
    # source://pay//lib/pay/nano_id.rb#7
    def generate(size: T.unsafe(nil)); end
  end
end

# Generates unique IDs - faster than UUID
#
# source://pay//lib/pay/nano_id.rb#4
Pay::NanoId::ALPHABET = T.let(T.unsafe(nil), String)

# source://pay//lib/pay/nano_id.rb#5
Pay::NanoId::ALPHABET_SIZE = T.let(T.unsafe(nil), Integer)

# source://pay//lib/pay/paddle.rb#2
module Pay::Paddle
  extend ::Pay::Env

  class << self
    # source://pay//lib/pay/paddle.rb#70
    def configure_webhooks; end

    # @return [Boolean]
    #
    # source://pay//lib/pay/paddle.rb#20
    def enabled?; end

    # source://pay//lib/pay/paddle.rb#40
    def environment; end

    # source://pay//lib/pay/paddle.rb#64
    def owner_from_passthrough(passthrough); end

    # source://pay//lib/pay/paddle.rb#60
    def parse_passthrough(passthrough); end

    # source://pay//lib/pay/paddle.rb#56
    def passthrough(owner:, **options); end

    # source://pay//lib/pay/paddle.rb#44
    def public_key; end

    # source://pay//lib/pay/paddle.rb#52
    def public_key_base64; end

    # source://pay//lib/pay/paddle.rb#48
    def public_key_file; end

    # source://pay//lib/pay/paddle.rb#26
    def setup; end

    # source://pay//lib/pay/paddle.rb#36
    def vendor_auth_code; end

    # source://pay//lib/pay/paddle.rb#32
    def vendor_id; end
  end
end

# source://pay//lib/pay/paddle/billable.rb#3
class Pay::Paddle::Billable
  # @return [Billable] a new instance of Billable
  #
  # source://pay//lib/pay/paddle/billable.rb#13
  def initialize(pay_customer); end

  # source://pay//lib/pay/paddle/billable.rb#52
  def add_payment_method(token, default: T.unsafe(nil)); end

  # source://pay//lib/pay/paddle/billable.rb#6
  def card_token(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/billable.rb#25
  def charge(amount, options = T.unsafe(nil)); end

  # source://pay//lib/pay/paddle/billable.rb#17
  def customer; end

  # source://pay//lib/pay/paddle/billable.rb#6
  def customer_name(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/billable.rb#6
  def email(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute pay_customer.
  #
  # source://pay//lib/pay/paddle/billable.rb#4
  def pay_customer; end

  # source://pay//lib/pay/paddle/billable.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/billable.rb#6
  def processor_id?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/billable.rb#61
  def processor_subscription(subscription_id, options = T.unsafe(nil)); end

  # source://pay//lib/pay/paddle/billable.rb#48
  def subscribe(name: T.unsafe(nil), plan: T.unsafe(nil), **options); end

  # source://pay//lib/pay/paddle/billable.rb#56
  def trial_end_date(subscription); end

  # source://pay//lib/pay/paddle/billable.rb#21
  def update_customer!; end
end

# source://pay//lib/pay/paddle/charge.rb#3
class Pay::Paddle::Charge
  # @return [Charge] a new instance of Charge
  #
  # source://pay//lib/pay/paddle/charge.rb#8
  def initialize(pay_charge); end

  # source://pay//lib/pay/paddle/charge.rb#12
  def charge; end

  # source://pay//lib/pay/paddle/charge.rb#6
  def customer(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute pay_charge.
  #
  # source://pay//lib/pay/paddle/charge.rb#4
  def pay_charge; end

  # source://pay//lib/pay/paddle/charge.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/charge.rb#21
  def refund!(amount_to_refund); end
end

# source://pay//lib/pay/paddle/error.rb#3
class Pay::Paddle::Error < ::Pay::Error
  # source://pay//lib/pay/paddle/error.rb#4
  def message(*_arg0, **_arg1, &_arg2); end
end

# source://pay//lib/pay/paddle/payment_method.rb#3
class Pay::Paddle::PaymentMethod
  # @return [PaymentMethod] a new instance of PaymentMethod
  #
  # source://pay//lib/pay/paddle/payment_method.rb#47
  def initialize(pay_payment_method); end

  # source://pay//lib/pay/paddle/payment_method.rb#6
  def customer(*_arg0, **_arg1, &_arg2); end

  # Remove payment method
  #
  # source://pay//lib/pay/paddle/payment_method.rb#56
  def detach; end

  # Sets payment method as default
  #
  # source://pay//lib/pay/paddle/payment_method.rb#52
  def make_default!; end

  # Returns the value of attribute pay_payment_method.
  #
  # source://pay//lib/pay/paddle/payment_method.rb#4
  def pay_payment_method; end

  # source://pay//lib/pay/paddle/payment_method.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  class << self
    # source://pay//lib/pay/paddle/payment_method.rb#24
    def payment_method_details_for(subscription_id:); end

    # Paddle doesn't provide PaymentMethod IDs, so we have to lookup via the Customer
    #
    # source://pay//lib/pay/paddle/payment_method.rb#9
    def sync(pay_customer:, attributes: T.unsafe(nil)); end
  end
end

# source://pay//lib/pay/paddle/subscription.rb#3
class Pay::Paddle::Subscription
  # @return [Subscription] a new instance of Subscription
  #
  # source://pay//lib/pay/paddle/subscription.rb#67
  def initialize(pay_subscription); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def active?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/subscription.rb#78
  def cancel(**options); end

  # source://pay//lib/pay/paddle/subscription.rb#96
  def cancel_now!(**options); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def canceled?(*_arg0, **_arg1, &_arg2); end

  # @raise [NotImplementedError]
  #
  # source://pay//lib/pay/paddle/subscription.rb#106
  def change_quantity(quantity, **options); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def ends_at(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def name(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://pay//lib/pay/paddle/subscription.rb#110
  def on_grace_period?; end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def on_trial?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def owner(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/subscription.rb#118
  def pause; end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def pause_starts_at(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://pay//lib/pay/paddle/subscription.rb#114
  def paused?; end

  # Returns the value of attribute pay_subscription.
  #
  # source://pay//lib/pay/paddle/subscription.rb#4
  def pay_subscription; end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def processor_plan(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def processor_subscription(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def prorate(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def prorate?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def quantity(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def quantity?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/paddle/subscription.rb#126
  def resume; end

  # Retries the latest invoice for a Past Due subscription
  #
  # source://pay//lib/pay/paddle/subscription.rb#151
  def retry_failed_payment; end

  # source://pay//lib/pay/paddle/subscription.rb#71
  def subscription(**options); end

  # source://pay//lib/pay/paddle/subscription.rb#138
  def swap(plan, **options); end

  # source://pay//lib/pay/paddle/subscription.rb#6
  def trial_ends_at(*_arg0, **_arg1, &_arg2); end

  class << self
    # source://pay//lib/pay/paddle/subscription.rb#24
    def sync(subscription_id, object: T.unsafe(nil), name: T.unsafe(nil)); end
  end
end

# source://pay//lib/pay/paddle.rb#9
module Pay::Paddle::Webhooks; end

# source://pay//lib/pay/paddle/webhooks/signature_verifier.rb#8
class Pay::Paddle::Webhooks::SignatureVerifier
  # @return [SignatureVerifier] a new instance of SignatureVerifier
  #
  # source://pay//lib/pay/paddle/webhooks/signature_verifier.rb#9
  def initialize(data); end

  # source://pay//lib/pay/paddle/webhooks/signature_verifier.rb#16
  def verify; end

  private

  # https://github.com/jqr/php-serialize/blob/master/lib/php_serialize.rb
  #
  # Returns a string representing the argument in a form PHP.unserialize
  # and PHP's unserialize() should both be able to load.
  #
  #   string = PHP.serialize(mixed var[, bool assoc])
  #
  # Array, Hash, Fixnum, Float, True/FalseClass, NilClass, String and Struct
  # are supported; as are objects which support the to_assoc method, which
  # returns an array of the form [['attr_name', 'value']..].  Anything else
  # will raise a TypeError.
  #
  # If 'assoc' is specified, Array's who's first element is a two value
  # array will be assumed to be an associative array, and will be serialized
  # as a PHP associative array rather than a multidimensional array.
  #
  # source://pay//lib/pay/paddle/webhooks/signature_verifier.rb#63
  def serialize(var, assoc = T.unsafe(nil)); end
end

# source://pay//lib/pay/paddle/webhooks/subscription_cancelled.rb#4
class Pay::Paddle::Webhooks::SubscriptionCancelled
  # source://pay//lib/pay/paddle/webhooks/subscription_cancelled.rb#5
  def call(event); end
end

# source://pay//lib/pay/paddle/webhooks/subscription_created.rb#4
class Pay::Paddle::Webhooks::SubscriptionCreated
  # source://pay//lib/pay/paddle/webhooks/subscription_created.rb#5
  def call(event); end
end

# source://pay//lib/pay/paddle/webhooks/subscription_payment_refunded.rb#4
class Pay::Paddle::Webhooks::SubscriptionPaymentRefunded
  # source://pay//lib/pay/paddle/webhooks/subscription_payment_refunded.rb#5
  def call(event); end
end

# source://pay//lib/pay/paddle/webhooks/subscription_payment_succeeded.rb#4
class Pay::Paddle::Webhooks::SubscriptionPaymentSucceeded
  # source://pay//lib/pay/paddle/webhooks/subscription_payment_succeeded.rb#5
  def call(event); end

  # source://pay//lib/pay/paddle/webhooks/subscription_payment_succeeded.rb#24
  def create_charge(pay_customer, event); end

  # source://pay//lib/pay/paddle/webhooks/subscription_payment_succeeded.rb#45
  def notify_user(pay_charge); end
end

# source://pay//lib/pay/paddle/webhooks/subscription_updated.rb#4
class Pay::Paddle::Webhooks::SubscriptionUpdated
  # source://pay//lib/pay/paddle/webhooks/subscription_updated.rb#5
  def call(event); end
end

# source://pay//lib/pay/payment.rb#2
class Pay::Payment
  # @return [Payment] a new instance of Payment
  #
  # source://pay//lib/pay/payment.rb#12
  def initialize(intent); end

  # source://pay//lib/pay/payment.rb#5
  def amount(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/payment.rb#44
  def amount_with_currency; end

  # @return [Boolean]
  #
  # source://pay//lib/pay/payment.rb#24
  def canceled?; end

  # @return [Boolean]
  #
  # source://pay//lib/pay/payment.rb#28
  def cancelled?; end

  # source://pay//lib/pay/payment.rb#5
  def client_secret(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/payment.rb#5
  def confirm(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/payment.rb#5
  def currency(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/payment.rb#5
  def customer(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/payment.rb#5
  def id(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute intent.
  #
  # source://pay//lib/pay/payment.rb#3
  def intent; end

  # @return [Boolean]
  #
  # source://pay//lib/pay/payment.rb#36
  def payment_intent?; end

  # @return [Boolean]
  #
  # source://pay//lib/pay/payment.rb#20
  def requires_action?; end

  # @return [Boolean]
  #
  # source://pay//lib/pay/payment.rb#16
  def requires_payment_method?; end

  # @return [Boolean]
  #
  # source://pay//lib/pay/payment.rb#40
  def setup_intent?; end

  # source://pay//lib/pay/payment.rb#5
  def status(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://pay//lib/pay/payment.rb#32
  def succeeded?; end

  # source://pay//lib/pay/payment.rb#48
  def validate; end

  class << self
    # source://pay//lib/pay/payment.rb#7
    def from_id(id); end
  end
end

# source://pay//lib/pay/errors.rb#6
class Pay::PaymentError < ::StandardError
  # @return [PaymentError] a new instance of PaymentError
  #
  # source://pay//lib/pay/errors.rb#9
  def initialize(payment); end

  # Returns the value of attribute payment.
  #
  # source://pay//lib/pay/errors.rb#7
  def payment; end
end

class Pay::PaymentMethod < ::Pay::ApplicationRecord
  include ::Pay::PaymentMethod::GeneratedAttributeMethods
  include ::Pay::PaymentMethod::GeneratedAssociationMethods

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_customer(*args); end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def clear_payment_method_type_change; end

  def make_default!; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type(*args, **_arg1); end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type=(value); end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type?; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_before_last_save; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_before_type_cast; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_came_from_user?; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_change; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_change_to_be_saved; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_changed?(**options); end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_for_database; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_in_database; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_previous_change; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_previously_changed?(**options); end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_previously_was; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_was; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def payment_method_type_will_change!; end

  def payment_processor; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def restore_payment_method_type!; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def saved_change_to_payment_method_type; end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def saved_change_to_payment_method_type?(**options); end

  # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#211
  def will_save_change_to_payment_method_type?(**options); end

  class << self
    # source://activesupport/7.0.4/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activerecord/7.0.4/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.0.4/lib/active_model/validations.rb#52
    def _validators; end

    # source://activemodel/7.0.4/lib/active_model/attribute_methods.rb#73
    def attribute_aliases; end

    # source://activerecord/7.0.4/lib/active_record/enum.rb#116
    def defined_enums; end

    def find_by_processor_and_id(processor, processor_id); end

    # source://activerecord/7.0.4/lib/active_record/model_schema.rb#160
    def inheritance_column; end

    def pay_processor_for(name); end
  end
end

module Pay::PaymentMethod::GeneratedAssociationMethods
  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#28
  def build_customer(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#32
  def create_customer(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_customer!(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#103
  def customer; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#111
  def customer=(value); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#132
  def customer_changed?; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#136
  def customer_previously_changed?; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_customer; end
end

module Pay::PaymentMethod::GeneratedAttributeMethods; end

class Pay::PaymentsController < ::Pay::ApplicationController
  def show; end

  private

  # source://actionview/7.0.4/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  class << self
    # source://actionview/7.0.4/lib/action_view/layouts.rb#209
    def _layout; end

    # source://actionview/7.0.4/lib/action_view/layouts.rb#210
    def _layout_conditions; end

    # source://actionpack/7.0.4/lib/action_controller/metal/params_wrapper.rb#185
    def _wrapper_options; end

    # source://actionpack/7.0.4/lib/action_controller/metal/helpers.rb#63
    def helpers_path; end

    # source://actionpack/7.0.4/lib/action_controller/metal.rb#210
    def middleware_stack; end
  end
end

# source://pay//lib/pay/receipts.rb#2
module Pay::Receipts
  # source://pay//lib/pay/receipts.rb#71
  def discount_description(discount); end

  # source://pay//lib/pay/receipts.rb#7
  def filename; end

  # source://pay//lib/pay/receipts.rb#135
  def invoice; end

  # source://pay//lib/pay/receipts.rb#139
  def invoice_details; end

  # source://pay//lib/pay/receipts.rb#131
  def invoice_filename; end

  # source://pay//lib/pay/receipts.rb#167
  def invoice_number; end

  # source://pay//lib/pay/receipts.rb#147
  def invoice_pdf(**options); end

  # source://pay//lib/pay/receipts.rb#24
  def pdf_line_items; end

  # source://pay//lib/pay/receipts.rb#3
  def product; end

  # source://pay//lib/pay/receipts.rb#12
  def receipt; end

  # source://pay//lib/pay/receipts.rb#16
  def receipt_details; end

  # source://pay//lib/pay/receipts.rb#7
  def receipt_filename; end

  # source://pay//lib/pay/receipts.rb#89
  def receipt_line_items; end

  # source://pay//lib/pay/receipts.rb#171
  def receipt_number; end

  # source://pay//lib/pay/receipts.rb#111
  def receipt_pdf(**options); end

  # source://pay//lib/pay/receipts.rb#82
  def tax_description(tax_amount); end
end

# source://pay//lib/pay/stripe.rb#2
module Pay::Stripe
  extend ::Pay::Env

  class << self
    # source://pay//lib/pay/stripe.rb#63
    def configure_webhooks; end

    # @return [Boolean]
    #
    # source://pay//lib/pay/stripe.rb#32
    def enabled?; end

    # source://pay//lib/pay/stripe.rb#55
    def private_key; end

    # source://pay//lib/pay/stripe.rb#51
    def public_key; end

    # source://pay//lib/pay/stripe.rb#38
    def setup; end

    # source://pay//lib/pay/stripe.rb#59
    def signing_secret; end
  end
end

# source://pay//lib/pay/stripe/billable.rb#3
class Pay::Stripe::Billable
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::Routing::UrlFor

  # @return [Billable] a new instance of Billable
  #
  # source://pay//lib/pay/stripe/billable.rb#21
  def initialize(pay_customer); end

  # source://pay//lib/pay/stripe/billable.rb#128
  def add_payment_method(payment_method_id, default: T.unsafe(nil)); end

  # source://pay//lib/pay/stripe/billable.rb#266
  def authorize(amount, options = T.unsafe(nil)); end

  # source://pay//lib/pay/stripe/billable.rb#257
  def billing_portal(**options); end

  # source://pay//lib/pay/stripe/billable.rb#80
  def charge(amount, options = T.unsafe(nil)); end

  # https://stripe.com/docs/api/checkout/sessions/create
  #
  # checkout(mode: "payment")
  # checkout(mode: "setup")
  # checkout(mode: "subscription")
  #
  # checkout(line_items: "price_12345", quantity: 2)
  # checkout(line_items: [{ price: "price_123" }, { price: "price_456" }])
  # checkout(line_items: "price_12345", allow_promotion_codes: true)
  #
  # source://pay//lib/pay/stripe/billable.rb#208
  def checkout(**options); end

  # https://stripe.com/docs/api/checkout/sessions/create
  #
  # checkout_charge(amount: 15_00, name: "T-shirt", quantity: 2)
  #
  # source://pay//lib/pay/stripe/billable.rb#241
  def checkout_charge(amount:, name:, quantity: T.unsafe(nil), **options); end

  # source://pay//lib/pay/stripe/billable.rb#174
  def create_setup_intent(options = T.unsafe(nil)); end

  # Retrieves a Stripe::Customer object
  #
  # Finds an existing Stripe::Customer if processor_id exists
  # Creates a new Stripe::Customer using `customer_attributes` if empty processor_id
  #
  # Updates the default payment method automatically if a payment_method_token is set
  #
  # Returns a Stripe::Customer object
  #
  # source://pay//lib/pay/stripe/billable.rb#50
  def customer; end

  # Returns a hash of attributes for the Stripe::Customer object
  #
  # source://pay//lib/pay/stripe/billable.rb#26
  def customer_attributes; end

  # source://pay//lib/pay/stripe/billable.rb#8
  def customer_name(*_arg0, **_arg1, &_arg2); end

  # source://actionpack/7.0.4/lib/action_dispatch/routing/url_for.rb#95
  def default_url_options; end

  # source://actionpack/7.0.4/lib/action_dispatch/routing/url_for.rb#95
  def default_url_options=(_arg0); end

  # source://actionpack/7.0.4/lib/action_dispatch/routing/url_for.rb#95
  def default_url_options?; end

  # source://pay//lib/pay/stripe/billable.rb#8
  def email(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/billable.rb#165
  def invoice!(options = T.unsafe(nil)); end

  # Returns the value of attribute pay_customer.
  #
  # source://pay//lib/pay/stripe/billable.rb#6
  def pay_customer; end

  # source://pay//lib/pay/stripe/billable.rb#8
  def payment_method_token(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/billable.rb#8
  def payment_method_token?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/billable.rb#8
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/billable.rb#8
  def processor_id?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/billable.rb#161
  def processor_subscription(subscription_id, options = T.unsafe(nil)); end

  # Save the Stripe::PaymentMethod to the database
  #
  # source://pay//lib/pay/stripe/billable.rb#146
  def save_payment_method(payment_method, default:); end

  # source://pay//lib/pay/stripe/billable.rb#8
  def stripe_account(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/billable.rb#102
  def subscribe(name: T.unsafe(nil), plan: T.unsafe(nil), **options); end

  # Syncs a customer's subscriptions from Stripe to the database.
  # Note that by default canceled subscriptions are NOT returned by Stripe. In order to include them, use `sync_subscriptions(status: "all")`.
  #
  # source://pay//lib/pay/stripe/billable.rb#189
  def sync_subscriptions(**options); end

  # source://pay//lib/pay/stripe/billable.rb#182
  def trial_end_date(stripe_sub); end

  # source://pay//lib/pay/stripe/billable.rb#170
  def upcoming_invoice; end

  # Syncs name and email to Stripe::Customer
  # You can also pass in other attributes that will be merged into the default attributes
  #
  # source://pay//lib/pay/stripe/billable.rb#71
  def update_customer!(**attributes); end

  private

  # Includes the `session_id` param for Stripe Checkout with existing params (and makes sure the curly braces aren't escaped)
  #
  # source://pay//lib/pay/stripe/billable.rb#278
  def merge_session_id_param(url); end

  # Options for Stripe requests
  #
  # source://pay//lib/pay/stripe/billable.rb#273
  def stripe_options; end

  class << self
    # source://actionpack/7.0.4/lib/action_dispatch/routing/route_set.rb#564
    def _routes; end

    # source://pay//lib/pay/stripe/billable.rb#17
    def default_url_options; end

    # source://actionpack/7.0.4/lib/action_dispatch/routing/url_for.rb#95
    def default_url_options=(value); end

    # source://actionpack/7.0.4/lib/action_dispatch/routing/url_for.rb#95
    def default_url_options?; end
  end
end

# source://pay//lib/pay/stripe/charge.rb#3
class Pay::Stripe::Charge
  # @return [Charge] a new instance of Charge
  #
  # source://pay//lib/pay/stripe/charge.rb#107
  def initialize(pay_charge); end

  # source://pay//lib/pay/stripe/charge.rb#6
  def amount(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/charge.rb#6
  def amount_captured(*_arg0, **_arg1, &_arg2); end

  # https://stripe.com/docs/payments/capture-later
  #
  # capture
  # capture(amount_to_capture: 15_00)
  #
  # source://pay//lib/pay/stripe/charge.rb#156
  def capture(**options); end

  # source://pay//lib/pay/stripe/charge.rb#111
  def charge; end

  # Adds a credit note to a Stripe Invoice
  #
  # source://pay//lib/pay/stripe/charge.rb#140
  def credit_note!(**options); end

  # @raise [Pay::Stripe::Error]
  #
  # source://pay//lib/pay/stripe/charge.rb#147
  def credit_notes(**options); end

  # source://pay//lib/pay/stripe/charge.rb#6
  def invoice_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/charge.rb#6
  def line_items(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute pay_charge.
  #
  # source://pay//lib/pay/stripe/charge.rb#4
  def pay_charge; end

  # source://pay//lib/pay/stripe/charge.rb#6
  def payment_intent_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/charge.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # Issues a CreditNote if there's an invoice, otherwise uses a Refund
  # This allows Tax to be handled properly
  #
  # https://stripe.com/docs/api/credit_notes/create
  # https://stripe.com/docs/api/refunds/create
  #
  # refund!
  # refund!(5_00)
  # refund!(5_00, refund_application_fee: true)
  #
  # source://pay//lib/pay/stripe/charge.rb#126
  def refund!(amount_to_refund, **options); end

  # source://pay//lib/pay/stripe/charge.rb#6
  def stripe_account(*_arg0, **_arg1, &_arg2); end

  private

  # Options for Stripe requests
  #
  # source://pay//lib/pay/stripe/charge.rb#167
  def stripe_options; end

  class << self
    # source://pay//lib/pay/stripe/charge.rb#15
    def sync(charge_id, object: T.unsafe(nil), stripe_account: T.unsafe(nil), try: T.unsafe(nil), retries: T.unsafe(nil)); end
  end
end

# source://pay//lib/pay/stripe/error.rb#3
class Pay::Stripe::Error < ::Pay::Error
  # source://pay//lib/pay/stripe/error.rb#4
  def message(*_arg0, **_arg1, &_arg2); end
end

# source://pay//lib/pay/stripe/merchant.rb#3
class Pay::Stripe::Merchant
  # @return [Merchant] a new instance of Merchant
  #
  # source://pay//lib/pay/stripe/merchant.rb#9
  def initialize(pay_merchant); end

  # source://pay//lib/pay/stripe/merchant.rb#29
  def account; end

  # source://pay//lib/pay/stripe/merchant.rb#35
  def account_link(refresh_url:, return_url:, type: T.unsafe(nil), **options); end

  # source://pay//lib/pay/stripe/merchant.rb#13
  def create_account(**options); end

  # A single-use login link for Express accounts to access their Stripe dashboard
  #
  # source://pay//lib/pay/stripe/merchant.rb#47
  def login_link(**options); end

  # Returns the value of attribute pay_merchant.
  #
  # source://pay//lib/pay/stripe/merchant.rb#4
  def pay_merchant; end

  # source://pay//lib/pay/stripe/merchant.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # Transfer money from the platform to this connected account
  # https://stripe.com/docs/connect/charges-transfers#transfer-availability
  #
  # source://pay//lib/pay/stripe/merchant.rb#55
  def transfer(amount:, currency: T.unsafe(nil), **options); end
end

# source://pay//lib/pay/stripe/payment_method.rb#3
class Pay::Stripe::PaymentMethod
  # @return [PaymentMethod] a new instance of PaymentMethod
  #
  # source://pay//lib/pay/stripe/payment_method.rb#8
  def initialize(pay_payment_method); end

  # source://pay//lib/pay/stripe/payment_method.rb#6
  def customer(*_arg0, **_arg1, &_arg2); end

  # Remove payment method
  #
  # source://pay//lib/pay/stripe/payment_method.rb#74
  def detach; end

  # Sets payment method as default
  #
  # source://pay//lib/pay/stripe/payment_method.rb#69
  def make_default!; end

  # Returns the value of attribute pay_payment_method.
  #
  # source://pay//lib/pay/stripe/payment_method.rb#4
  def pay_payment_method; end

  # source://pay//lib/pay/stripe/payment_method.rb#6
  def processor_id(*_arg0, **_arg1, &_arg2); end

  private

  # Options for Stripe requests
  #
  # source://pay//lib/pay/stripe/payment_method.rb#81
  def stripe_options; end

  class << self
    # Extracts payment method details from a Stripe::PaymentMethod object
    #
    # source://pay//lib/pay/stripe/payment_method.rb#55
    def extract_attributes(payment_method); end

    # Syncs PaymentMethod objects from Stripe
    #
    # source://pay//lib/pay/stripe/payment_method.rb#29
    def sync(id, object: T.unsafe(nil), stripe_account: T.unsafe(nil), try: T.unsafe(nil), retries: T.unsafe(nil)); end

    # Syncs a PaymentIntent's payment method to the database
    #
    # source://pay//lib/pay/stripe/payment_method.rb#13
    def sync_payment_intent(id, stripe_account: T.unsafe(nil)); end

    # Syncs a SetupIntent's payment method to the database
    #
    # source://pay//lib/pay/stripe/payment_method.rb#21
    def sync_setup_intent(id, stripe_account: T.unsafe(nil)); end
  end
end

# source://pay//lib/pay/stripe/subscription.rb#3
class Pay::Stripe::Subscription
  # @return [Subscription] a new instance of Subscription
  #
  # source://pay//lib/pay/stripe/subscription.rb#133
  def initialize(pay_subscription); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def active?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#152
  def cancel(**options); end

  # Cancels a subscription immediately
  #
  # cancel_now!(prorate: true)
  # cancel_now!(invoice_now: true)
  #
  # source://pay//lib/pay/stripe/subscription.rb#163
  def cancel_now!(**options); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def canceled?(*_arg0, **_arg1, &_arg2); end

  # This updates a SubscriptionItem's quantity in Stripe
  #
  # For a subscription with a single item, we can update the subscription directly if no SubscriptionItem ID is available
  # Otherwise a SubscriptionItem ID is required so Stripe knows which entry to update
  #
  # source://pay//lib/pay/stripe/subscription.rb#174
  def change_quantity(quantity, **options); end

  # Returns a SetupIntent or PaymentIntent client secret for the subscription
  #
  # source://pay//lib/pay/stripe/subscription.rb#147
  def client_secret; end

  # Creates a metered billing usage record
  #
  # Uses the first subscription_item ID unless `subscription_item_id: "si_1234"` is passed
  #
  # create_usage_record(quantity: 4, action: :increment)
  # create_usage_record(subscription_item_id: "si_1234", quantity: 100, action: :set)
  #
  # source://pay//lib/pay/stripe/subscription.rb#280
  def create_usage_record(**options); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def current_period_end(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def current_period_start(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def ends_at(*_arg0, **_arg1, &_arg2); end

  # Returns the first metered subscription item
  #
  # source://pay//lib/pay/stripe/subscription.rb#292
  def metered_subscription_item; end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def name(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def on_grace_period?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def on_trial?(*_arg0, **_arg1, &_arg2); end

  # Pauses a Stripe subscription
  #
  # pause(behavior: "mark_uncollectible")
  # pause(behavior: "keep_as_draft")
  # pause(behavior: "void")
  # pause(behavior: "mark_uncollectible", resumes_at: 1.month.from_now)
  #
  # `void` - If you cant provide your services for a certain period of time, you can void invoices that are created by your subscriptions so that your customers arent charged.
  # `keep_as_draft` - If you want to temporarily offer your services for free and collect payments later
  # `mark_uncollectible` - If you want to offer your services for free
  #
  # pause_behavior of `void` is considered active until the end of the current period and not active after that. The current_period_end is stored as `pause_starts_at`
  # Other pause_behaviors do not set `pause_starts_at` because they are used for offering free services
  #
  # source://pay//lib/pay/stripe/subscription.rb#204
  def pause(**options); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def pause_behavior(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def pause_resumes_at(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://pay//lib/pay/stripe/subscription.rb#187
  def paused?; end

  # Returns the value of attribute pay_subscription.
  #
  # source://pay//lib/pay/stripe/subscription.rb#5
  def pay_subscription; end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def processor_id(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def processor_plan(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def processor_subscription(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def prorate(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def prorate?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def quantity(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def quantity?(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#142
  def reload!; end

  # source://pay//lib/pay/stripe/subscription.rb#225
  def resume; end

  # Retries the latest invoice for a Past Due subscription and attempts to pay it
  #
  # source://pay//lib/pay/stripe/subscription.rb#304
  def retry_failed_payment; end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def stripe_account(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute stripe_subscription.
  #
  # source://pay//lib/pay/stripe/subscription.rb#4
  def stripe_subscription; end

  # Sets the attribute stripe_subscription
  #
  # @param value the value to set the attribute stripe_subscription to.
  #
  # source://pay//lib/pay/stripe/subscription.rb#4
  def stripe_subscription=(_arg0); end

  # source://pay//lib/pay/stripe/subscription.rb#137
  def subscription(**options); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def subscription_items(*_arg0, **_arg1, &_arg2); end

  # source://pay//lib/pay/stripe/subscription.rb#247
  def swap(plan, **options); end

  # source://pay//lib/pay/stripe/subscription.rb#7
  def trial_ends_at(*_arg0, **_arg1, &_arg2); end

  # Unpauses a subscription
  #
  # source://pay//lib/pay/stripe/subscription.rb#216
  def unpause; end

  # Returns an upcoming invoice for a subscription
  #
  # source://pay//lib/pay/stripe/subscription.rb#299
  def upcoming_invoice(**options); end

  # Returns usage record summaries for a subscription item
  #
  # source://pay//lib/pay/stripe/subscription.rb#286
  def usage_record_summaries(**options); end

  private

  # source://pay//lib/pay/stripe/subscription.rb#318
  def expand_options; end

  # Options for Stripe requests
  #
  # source://pay//lib/pay/stripe/subscription.rb#314
  def stripe_options; end

  class << self
    # Common expand options for all requests that create, retrieve, or update a Stripe Subscription
    #
    # source://pay//lib/pay/stripe/subscription.rb#121
    def expand_options; end

    # source://pay//lib/pay/stripe/subscription.rb#29
    def sync(subscription_id, object: T.unsafe(nil), name: T.unsafe(nil), stripe_account: T.unsafe(nil), try: T.unsafe(nil), retries: T.unsafe(nil)); end
  end
end

# source://pay//lib/pay/stripe.rb#10
module Pay::Stripe::Webhooks; end

# source://pay//lib/pay/stripe/webhooks/account_updated.rb#4
class Pay::Stripe::Webhooks::AccountUpdated
  # source://pay//lib/pay/stripe/webhooks/account_updated.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/charge_refunded.rb#4
class Pay::Stripe::Webhooks::ChargeRefunded
  # source://pay//lib/pay/stripe/webhooks/charge_refunded.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/charge_succeeded.rb#4
class Pay::Stripe::Webhooks::ChargeSucceeded
  # source://pay//lib/pay/stripe/webhooks/charge_succeeded.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/checkout_session_async_payment_succeeded.rb#4
class Pay::Stripe::Webhooks::CheckoutSessionAsyncPaymentSucceeded < ::Pay::Stripe::Webhooks::CheckoutSessionCompleted; end

# source://pay//lib/pay/stripe/webhooks/checkout_session_completed.rb#4
class Pay::Stripe::Webhooks::CheckoutSessionCompleted
  # source://pay//lib/pay/stripe/webhooks/checkout_session_completed.rb#5
  def call(event); end

  # source://pay//lib/pay/stripe/webhooks/checkout_session_completed.rb#22
  def locate_owner(object); end
end

# source://pay//lib/pay/stripe/webhooks/customer_deleted.rb#4
class Pay::Stripe::Webhooks::CustomerDeleted
  # source://pay//lib/pay/stripe/webhooks/customer_deleted.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/customer_updated.rb#4
class Pay::Stripe::Webhooks::CustomerUpdated
  # source://pay//lib/pay/stripe/webhooks/customer_updated.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/payment_action_required.rb#4
class Pay::Stripe::Webhooks::PaymentActionRequired
  # source://pay//lib/pay/stripe/webhooks/payment_action_required.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/payment_intent_succeeded.rb#4
class Pay::Stripe::Webhooks::PaymentIntentSucceeded
  # This webhook does NOT send notifications because stripe sends both
  # `charge.succeeded` and `payment_intent.succeeded` events.
  #
  # We use `charge.succeeded` as the single place to send notifications
  #
  # source://pay//lib/pay/stripe/webhooks/payment_intent_succeeded.rb#10
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/payment_method_attached.rb#4
class Pay::Stripe::Webhooks::PaymentMethodAttached
  # source://pay//lib/pay/stripe/webhooks/payment_method_attached.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/payment_method_detached.rb#4
class Pay::Stripe::Webhooks::PaymentMethodDetached
  # source://pay//lib/pay/stripe/webhooks/payment_method_detached.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/payment_method_updated.rb#4
class Pay::Stripe::Webhooks::PaymentMethodUpdated
  # source://pay//lib/pay/stripe/webhooks/payment_method_updated.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/subscription_created.rb#4
class Pay::Stripe::Webhooks::SubscriptionCreated
  # source://pay//lib/pay/stripe/webhooks/subscription_created.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/subscription_deleted.rb#4
class Pay::Stripe::Webhooks::SubscriptionDeleted
  # source://pay//lib/pay/stripe/webhooks/subscription_deleted.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/subscription_renewing.rb#4
class Pay::Stripe::Webhooks::SubscriptionRenewing
  # Handles `invoice.upcoming` webhook from Stripe
  # Occurs X number of days before a subscription is scheduled to create an invoice that is automatically chargedwhere X is determined by your subscriptions settings. Note: The received Invoice object will not have an invoice ID.
  #
  # source://pay//lib/pay/stripe/webhooks/subscription_renewing.rb#8
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/subscription_trial_will_end.rb#4
class Pay::Stripe::Webhooks::SubscriptionTrialWillEnd
  # source://pay//lib/pay/stripe/webhooks/subscription_trial_will_end.rb#5
  def call(event); end
end

# source://pay//lib/pay/stripe/webhooks/subscription_updated.rb#4
class Pay::Stripe::Webhooks::SubscriptionUpdated
  # source://pay//lib/pay/stripe/webhooks/subscription_updated.rb#5
  def call(event); end
end

class Pay::Subscription < ::Pay::ApplicationRecord
  include ::Pay::Subscription::GeneratedAttributeMethods
  include ::Pay::Subscription::GeneratedAssociationMethods

  def active?; end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_charges(*args); end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_customer(*args); end

  def braintree?; end
  def canceled?; end
  def cancelled?; end
  def change_quantity(quantity, **options); end
  def fake_processor?; end
  def generic_trial?; end
  def has_incomplete_payment?; end
  def has_trial?; end
  def incomplete?; end
  def latest_payment; end

  # source://activesupport/7.0.4/lib/active_support/core_ext/module/delegation.rb#302
  def method_missing(method, *args, **_arg2, &block); end

  def no_prorate; end
  def on_grace_period?; end
  def on_trial?; end
  def paddle?; end
  def past_due?; end
  def pause_active?; end
  def payment_processor; end
  def processor_subscription(**options); end
  def resume; end
  def skip_trial; end
  def stripe?; end
  def swap(plan, **options); end
  def swap_and_invoice(plan); end
  def sync!(**options); end
  def trial_ended?; end

  # source://activerecord/7.0.4/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_charges(*args); end

  def will_pause?; end

  private

  def cancel_if_active; end

  # source://activesupport/7.0.4/lib/active_support/core_ext/module/delegation.rb#294
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    # source://activesupport/7.0.4/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activerecord/7.0.4/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.0.4/lib/active_model/validations.rb#52
    def _validators; end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def active(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def active_or_paused(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads; end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def braintree(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def cancelled(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/enum.rb#116
    def defined_enums; end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def fake_processor(*args, **_arg1); end

    def find_by_processor_and_id(processor, processor_id); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def for_name(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def incomplete(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def metered(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def on_grace_period(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def on_trial(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def paddle(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def past_due(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def pause_not_started(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def paused(*args, **_arg1); end

    def pay_processor_for(name); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def stripe(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def with_active_customer(*args, **_arg1); end

    # source://activerecord/7.0.4/lib/active_record/scoping/named.rb#174
    def with_deleted_customer(*args, **_arg1); end
  end
end

module Pay::Subscription::GeneratedAssociationMethods
  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#28
  def build_customer(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/collection_association.rb#62
  def charge_ids; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/collection_association.rb#72
  def charge_ids=(ids); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#103
  def charges; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#111
  def charges=(value); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#32
  def create_customer(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_customer!(*args, &block); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#103
  def customer; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/association.rb#111
  def customer=(value); end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#132
  def customer_changed?; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/belongs_to.rb#136
  def customer_previously_changed?; end

  # source://activerecord/7.0.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_customer; end
end

module Pay::Subscription::GeneratedAttributeMethods; end
Pay::Subscription::STATUSES = T.let(T.unsafe(nil), Array)

class Pay::UserMailer < ::Pay::ApplicationMailer
  def payment_action_required; end
  def receipt; end
  def refund; end
  def subscription_renewing; end
  def subscription_trial_ended; end
  def subscription_trial_will_end; end

  private

  # source://actionview/7.0.4/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  def mail_arguments; end
end

# source://pay//lib/pay/version.rb#2
Pay::VERSION = T.let(T.unsafe(nil), String)

class Pay::Webhook < ::Pay::ApplicationRecord
  include ::Pay::Webhook::GeneratedAttributeMethods
  include ::Pay::Webhook::GeneratedAssociationMethods

  def process!; end
  def rehydrated_event; end
  def to_recursive_ostruct(hash); end

  class << self
    # source://activesupport/7.0.4/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activemodel/7.0.4/lib/active_model/validations.rb#52
    def _validators; end

    # source://activerecord/7.0.4/lib/active_record/enum.rb#116
    def defined_enums; end
  end
end

module Pay::Webhook::GeneratedAssociationMethods; end
module Pay::Webhook::GeneratedAttributeMethods; end

# source://pay//lib/pay/webhooks.rb#2
module Pay::Webhooks
  class << self
    # source://pay//lib/pay/webhooks.rb#7
    def configure(*_arg0, **_arg1, &_arg2); end

    # source://pay//lib/pay/webhooks.rb#9
    def delegator; end

    # source://pay//lib/pay/webhooks.rb#7
    def instrument(*_arg0, **_arg1, &_arg2); end
  end
end

class Pay::Webhooks::BraintreeController < ::Pay::ApplicationController
  def create; end

  private

  # source://actionview/7.0.4/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  def queue_event(event); end
  def verified_event; end

  class << self
    # source://activesupport/7.0.4/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://actionpack/7.0.4/lib/action_controller/metal/params_wrapper.rb#185
    def _wrapper_options; end

    # source://actionpack/7.0.4/lib/action_controller/metal/helpers.rb#63
    def helpers_path; end

    # source://actionpack/7.0.4/lib/action_controller/metal.rb#210
    def middleware_stack; end
  end
end

# source://pay//lib/pay/webhooks/delegator.rb#3
class Pay::Webhooks::Delegator
  # @return [Delegator] a new instance of Delegator
  #
  # source://pay//lib/pay/webhooks/delegator.rb#6
  def initialize; end

  # Listen to all events
  #
  # source://pay//lib/pay/webhooks/delegator.rb#23
  def all(callable = T.unsafe(nil), &block); end

  # Returns the value of attribute backend.
  #
  # source://pay//lib/pay/webhooks/delegator.rb#4
  def backend; end

  # Configure DSL
  #
  # @raise [ArgumentError]
  #
  # source://pay//lib/pay/webhooks/delegator.rb#11
  def configure(&block); end

  # Called to process an event
  #
  # source://pay//lib/pay/webhooks/delegator.rb#34
  def instrument(event:, type:); end

  # @return [Boolean]
  #
  # source://pay//lib/pay/webhooks/delegator.rb#38
  def listening?(type); end

  # Subscribe to specific events
  #
  # source://pay//lib/pay/webhooks/delegator.rb#17
  def subscribe(name, callable = T.unsafe(nil), &block); end

  # Unsubscribe
  #
  # source://pay//lib/pay/webhooks/delegator.rb#29
  def unsubscribe(name); end

  private

  # source://pay//lib/pay/webhooks/delegator.rb#60
  def name_with_namespace(name, delimiter: T.unsafe(nil)); end

  # source://pay//lib/pay/webhooks/delegator.rb#56
  def to_regexp(name); end
end

# Strips down to event data only
#
# source://pay//lib/pay/webhooks/delegator.rb#43
class Pay::Webhooks::Delegator::NotificationAdapter
  # @return [NotificationAdapter] a new instance of NotificationAdapter
  #
  # source://pay//lib/pay/webhooks/delegator.rb#44
  def initialize(subscriber); end

  # source://pay//lib/pay/webhooks/delegator.rb#48
  def call(*args); end
end

class Pay::Webhooks::PaddleController < ::Pay::ApplicationController
  def create; end

  private

  # source://actionview/7.0.4/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  def queue_event(event); end
  def verified_event; end
  def verify_params; end

  class << self
    # source://activesupport/7.0.4/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://actionpack/7.0.4/lib/action_controller/metal/params_wrapper.rb#185
    def _wrapper_options; end

    # source://actionpack/7.0.4/lib/action_controller/metal/helpers.rb#63
    def helpers_path; end

    # source://actionpack/7.0.4/lib/action_controller/metal.rb#210
    def middleware_stack; end
  end
end

# source://pay//lib/pay/webhooks/process_job.rb#3
class Pay::Webhooks::ProcessJob < ::Pay::ApplicationJob
  # source://pay//lib/pay/webhooks/process_job.rb#4
  def perform(pay_webhook); end
end

class Pay::Webhooks::StripeController < ::Pay::ApplicationController
  def create; end

  private

  # source://actionview/7.0.4/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  def log_error(e); end
  def queue_event(event); end
  def secrets(payload, signature); end
  def verified_event; end

  class << self
    # source://activesupport/7.0.4/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://actionpack/7.0.4/lib/action_controller/metal/params_wrapper.rb#185
    def _wrapper_options; end

    # source://actionpack/7.0.4/lib/action_controller/metal/helpers.rb#63
    def helpers_path; end

    # source://actionpack/7.0.4/lib/action_controller/metal.rb#210
    def middleware_stack; end
  end
end
