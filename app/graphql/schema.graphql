"""
Requires that exactly one field must be supplied and that field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

"""Autogenerated input type of AccountUpdate"""
input AccountUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  name: String!
}

"""Autogenerated return type of AccountUpdate."""
type AccountUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [ValidationError!]
  user: User
}

"""An ISO 8601-encoded date"""
scalar Date

"""An object with an ID."""
interface Identifiable implements Node {
  """ID of the object."""
  id: ID!

  """ShortID of the object."""
  shortId: ShortID!
}

type Mutation {
  accountUpdate(
    """Parameters for AccountUpdate"""
    input: AccountUpdateInput!
  ): AccountUpdatePayload!
  testMutation(
    """Parameters for TestMutation"""
    input: TestMutationInput!
  ): TestMutationPayload!
}

"""An object with an ID."""
interface Node {
  """ID of the object."""
  id: ID!
}

type Query {
  """The currently authenticated user."""
  authenticatedViewer: User!
  testEcho(text: String): String!

  """The currently authenticated user."""
  viewer: User
}

"""
Represents a unique identifier that is Base64 obfuscated. It is often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"VXNlci0xMA=="`) or integer (such as `4`) input value will be accepted as an ID.
"""
scalar ShortID

type Subscription {
  testSubscription: Int!
}

type TestModel {
  birthday: Date
  id: ID!
  name: String!
}

"""Autogenerated input type of TestMutation"""
input TestMutationInput {
  birthday: Date

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  name: String!
}

"""Autogenerated return type of TestMutation."""
type TestMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [ValidationError!]
  model: TestModel
}

type User implements Identifiable & Node {
  email: String!

  """ID of the object."""
  id: ID!
  isOwner: Boolean!
  name: String!

  """ShortID of the object."""
  shortId: ShortID!
  unconfirmedEmail: String
}

type ValidationError {
  field: String!
  message: String!
}