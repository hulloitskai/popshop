"""
Requires that exactly one field must be supplied and that field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

type Account implements Node {
  canDelete: Boolean!
  canEdit: Boolean!

  """ID of the object."""
  id: ID!
  name: String!
  owner: User!
  products: [Product!]!
}

"""Autogenerated input type of AccountUpdate"""
input AccountUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  name: String!
}

"""Autogenerated return type of AccountUpdate."""
type AccountUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [InputFieldError!]
  user: User
}

type Currency {
  code: String!
  exponent: Int!
  name: String!
  symbol: String!
}

"""An ISO 8601-encoded date"""
scalar Date

type InputFieldError {
  field: String!
  message: String!
}

type Mutation {
  accountUpdate(
    """Parameters for AccountUpdate"""
    input: AccountUpdateInput!
  ): AccountUpdatePayload!
  productCreate(
    """Parameters for ProductCreate"""
    input: ProductCreateInput!
  ): ProductCreatePayload!
  productUpdate(
    """Parameters for ProductUpdate"""
    input: ProductUpdateInput!
  ): ProductUpdatePayload!
  testMutation(
    """Parameters for TestMutation"""
    input: TestMutationInput!
  ): TestMutationPayload!
}

"""An object with an ID."""
interface Node {
  """ID of the object."""
  id: ID!
}

type Price implements Node {
  amount: String!
  amountCents: Int!
  currencyCode: String!

  """ID of the object."""
  id: ID!
  name: String
  scope: Scope!
  units: Units
}

input PriceInput {
  amount: String
  amountCents: Int
  name: String!
  scope: Scope!
  units: String
}

type Product implements Node {
  account: Account!
  canDelete: Boolean!
  canEdit: Boolean!
  currencyCode: String!
  description: String
  editUrl: String!

  """ID of the object."""
  id: ID!
  name: String!
  prices: [Price!]!
  url: String!
}

"""Autogenerated input type of ProductCreate"""
input ProductCreateInput {
  accountId: ID

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  currencyCode: String!
  description: String
  name: String!
  prices: [PriceInput!]!
}

"""Autogenerated return type of ProductCreate."""
type ProductCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [InputFieldError!]
  product: Product
}

"""Autogenerated input type of ProductUpdate"""
input ProductUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  description: String
  name: String!
  prices: [PriceInput!]!
  productId: ID!
}

"""Autogenerated return type of ProductUpdate."""
type ProductUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [InputFieldError!]
  product: Product
}

type Query {
  currencies: [Currency!]!
  currency(code: String!): Currency
  product(id: ID!): Product!
  testEcho(text: String): String!

  """The currently authenticated user."""
  viewer: User
}

enum Scope {
  PER_ORDER
  PER_PERSON
  PER_UNIT
}

type Subscription {
  testSubscription: Int!
}

type TestModel {
  birthday: Date
  id: ID!
  name: String!
}

"""Autogenerated input type of TestMutation"""
input TestMutationInput {
  birthday: Date

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  name: String!
}

"""Autogenerated return type of TestMutation."""
type TestMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [InputFieldError!]
  model: TestModel
}

type Units {
  plural: String!
  singular: String!
}

type User implements Node {
  email: String!

  """ID of the object."""
  id: ID!
  name: String!
  primaryAccount: Account!
  unconfirmedEmail: String
}