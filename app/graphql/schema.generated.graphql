"""
Requires that exactly one field must be supplied and that field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

type Account implements Node {
  canDelete: Boolean!
  canEdit: Boolean!

  """ID of the object."""
  id: ID!
  isStripeConnected: Boolean!
  name: String!
  orders(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): OrderConnection!
  owner: User!
  products: [Product!]!
  stripeDashboardUrl: String
}

"""Autogenerated input type of AccountOnboardToStripe"""
input AccountOnboardToStripeInput {
  accountId: ID

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of AccountOnboardToStripe."""
type AccountOnboardToStripePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  url: String!
}

type Currency {
  code: String!
  exponent: Int!
  name: String!
  symbol: String!
}

type Customer implements Node {
  account: Account!
  email: String!
  firstName: String!

  """ID of the object."""
  id: ID!
  lastName: String!
}

input CustomerInput {
  email: String!
  firstName: String!
  lastName: String!
}

"""An ISO 8601-encoded date"""
scalar Date

"""An ISO 8601-encoded datetime"""
scalar DateTime

type InputFieldError {
  field: String!
  message: String!
}

type Mutation {
  accountOnboardToStripe(
    """Parameters for AccountOnboardToStripe"""
    input: AccountOnboardToStripeInput!
  ): AccountOnboardToStripePayload!
  orderCreate(
    """Parameters for OrderCreate"""
    input: OrderCreateInput!
  ): OrderCreatePayload!
  productCreate(
    """Parameters for ProductCreate"""
    input: ProductCreateInput!
  ): ProductCreatePayload!
  productUpdate(
    """Parameters for ProductUpdate"""
    input: ProductUpdateInput!
  ): ProductUpdatePayload!
  testMutation(
    """Parameters for TestMutation"""
    input: TestMutationInput!
  ): TestMutationPayload!
  userChangeEmail(
    """Parameters for UserChangeEmail"""
    input: UserChangeEmailInput!
  ): UserChangeEmailPayload!
  userUpdate(
    """Parameters for UserUpdate"""
    input: UserUpdateInput!
  ): UserUpdatePayload!
}

"""An object with an ID."""
interface Node {
  """ID of the object."""
  id: ID!
}

type Order implements Node {
  account: Account!
  code: String!
  createdAt: DateTime!
  customer: Customer!

  """ID of the object."""
  id: ID!
  items: [OrderItem!]!
  product: Product!
  stripeCheckoutSessionUrl: String!
  stripePaymentIntentUrl: String
}

"""The connection type for Order."""
type OrderConnection {
  """A list of edges."""
  edges: [OrderEdge!]!

  """A list of nodes."""
  nodes: [Order!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalCount: Int!
}

"""Autogenerated input type of OrderCreate"""
input OrderCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customer: CustomerInput!
  items: [OrderItemInput!]!
  productId: ID!
}

"""Autogenerated return type of OrderCreate."""
type OrderCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [InputFieldError!]
  order: Order
}

"""An edge in a connection."""
type OrderEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Order!
}

type OrderItem implements Node {
  currency: Currency!

  """ID of the object."""
  id: ID!
  productItem: ProductItem!
  quantity: Int!
  subtotal: String!
  subtotalCents: Int!
}

input OrderItemInput {
  productItemId: ID!
  quantity: Int!
}

enum OrderScope {
  PER_ORDER
  PER_PERSON
  PER_UNIT
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type Product implements Node {
  account: Account!
  canDelete: Boolean!
  canEdit: Boolean!
  currency: Currency!
  description: String
  editUrl: String!

  """ID of the object."""
  id: ID!
  items: [ProductItem!]!
  name: String!
  url: String!
}

"""Autogenerated input type of ProductCreate"""
input ProductCreateInput {
  accountId: ID

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  currencyCode: String!
  description: String
  items: [ProductItemInput!]!
  name: String!
}

"""Autogenerated return type of ProductCreate."""
type ProductCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [InputFieldError!]
  product: Product
}

type ProductItem implements Node {
  currency: Currency!
  description: String

  """ID of the object."""
  id: ID!
  name: String!
  orderScope: OrderScope!
  price: String!
  priceCents: Int!
  questions: [ProductItemQuestion!]!
  units: Units
}

input ProductItemInput {
  description: String
  name: String!
  orderScope: OrderScope!
  price: String
  priceCents: Int
  questions: [ProductItemQuestionInput!]
  units: String
}

type ProductItemQuestion implements Node {
  choices: [String!]

  """ID of the object."""
  id: ID!
  prompt: String!
  type: QuestionType!
}

input ProductItemQuestionInput {
  choices: [String!]
  prompt: String!
  type: QuestionType!
}

"""Autogenerated input type of ProductUpdate"""
input ProductUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  description: String
  items: [ProductItemInput!]!
  name: String!
  productId: ID!
}

"""Autogenerated return type of ProductUpdate."""
type ProductUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [InputFieldError!]
  product: Product
}

type Query {
  currencies: [Currency!]!
  currency(code: String!): Currency
  product(id: ID!): Product!
  testEcho(text: String): String!

  """The currently authenticated user."""
  viewer: User
}

enum QuestionType {
  CHECKBOX
  LONG_ANSWER
  MULTIPLE_CHOICE
  SHORT_ANSWER
  SINGLE_CHOICE
}

type Subscription {
  testSubscription: Int!
}

type TestModel {
  birthday: Date
  id: ID!
  name: String!
}

"""Autogenerated input type of TestMutation"""
input TestMutationInput {
  birthday: Date

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  name: String!
}

"""Autogenerated return type of TestMutation."""
type TestMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [InputFieldError!]
  model: TestModel
}

type Units {
  plural: String!
  singular: String!
}

type User implements Node {
  email: String!

  """ID of the object."""
  id: ID!
  name: String!
  primaryAccount: Account!
  unconfirmedEmail: String
}

"""Autogenerated input type of UserChangeEmail"""
input UserChangeEmailInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  currentPassword: String!
  email: String!
}

"""Autogenerated return type of UserChangeEmail."""
type UserChangeEmailPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [InputFieldError!]
  user: User
}

"""Autogenerated input type of UserUpdate"""
input UserUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  name: String!
}

"""Autogenerated return type of UserUpdate."""
type UserUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [InputFieldError!]
  user: User
}